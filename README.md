# Spring-Basic
<br>
https://agilemanifesto.org/iso/ko/manifesto.html

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)
<br>

### SRP(Single responsibility principle) 단일 책임 원칙 
1.한 클래스는 하나의 책임만 가져야한다.(문맥과 상황에 따라)<br>
2.중요한 기준은 변경이다.변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것<br>
<br><br>
### OCP(Open/closed principle) 개방-폐쇄 원칙
1.소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.<br>
다형성을 통한 객체 확장, 코드의 변경은 없는 것이 좋음 but, 원칙을 지킬수 없다. ->Spring container가 해결<br>
<br><br>
### LSP(Liskov substitution principle) 리스코프 치환 원칙
1.프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.<br> 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
<br><br>
### ISP(Interface segregation principle) 인터페이스 분리 원칙
1.특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.<br> 
ex) 자동차 인터페이스 -> 운전,정비 인터페이스로 분리 
<br><br>
### DIP(Dependancy inversion principle) 의존관계 역전 원칙 
1.프로그래머는 "추상화에 의존해야지,구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.<br> -> 구현클래스에 의존하지 않고 인터페이스에 의존, 역할에 의존하게 해야 하는것과 같다.

<br><br>
결론:다형성 만으로는 OCP,DIP를 지킬수 없다. 무언가 더 필요하다.
<br><br>
## IOC,DI,컨테이너
<br>

### 제어의 역전 IOC(Inversion Of Control)
구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.하지만 AppConfig가 등장한 이후 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. <br>
이제 프로그램의 제어 흐름은 AppConfig가 가져간다. 기존의 서비스는 자신의 로직만 묵묵히 수행할 뿐이다.<br>
이렇게 제어의 흐름을 외부에서 관리하는 것을 제어의 역전(IOC)라 한다.<br>
<br><br>
### 의존관계 주입 DI(Dependancy Injection)
의존관계는 정적인 클래스 의존 관계와,실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 들을 분리해서 생각해야한다.<br>
정적인 클래스 의존관계:애플리케이션을 실행하지 않아도 분석할수 있다. ex) import문 <br>
하지만 이러한 코드는 실제로 어떤 객체가 service에 주입되는지 알수 없다.<br>
동적인 객체 의존관계:실행 시점에서 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는것을 의존관계 주입이라 한다.<br>

<br>

## SingleTonPattern
클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴.<br>
private 생성자를 통해 외부에서 임의로 new키워드를 사용하지 못하도록 막아야 한다.<br>
싱글톤 패턴은 이미 만들어진 객체를 공유해서 효율적으로 사용 가능하다. 하지만 다음과 같은 문제점이 있다.<br>
클라이언트가 구체 클래스를 의존해야한다.(DIP 위반) -> 해결방법 : 싱글톤 컨테이너<br>
스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
싱글톤 방식의 문제점:하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지하게 설계하면 안된다.<br>
즉, 무상태,가급적 읽기 전용으로 설계한다. -> 필드 대신에 자바에서 공유되지 않는 지역변수,파라미터,ThreadLocal등을 사용해야한다.<br>
CGLIB(AppConfig의 자식 타입)을 통해 새로운 객체를 만들어 컨테이너에 instance를 저장한다.




